<!DOCTYPE html>
<html lang="en-US"><head>
		<meta charset="UTF-8">
		<title>FT932-14129</title>
	</head>
	<body>
		<main>
			<p>930420 FT  20 APR 93 / Survey of A-Z of Computing (18): The next stage of evolution  -For Query language THE QUERY language is a way of giving non-programming users a handle on information, in effect giving them control of their own data. A mass of data is like a monochrome map: the information is there if you know how to look for it, but interpretation is a matter of expertise. To bring the picture to life, one needs to interrogate it, arrange it into patterns, and draw conclusions from it. SQL is the most famous of the breed, the Structured Query Language which could stand as a symbol of the 1980s' movement towards giving power to the users. Its progenitor was the relational database (rdbms), the form of database which makes it possible to relate or connect items of data. Relational database brought about the users's ability to interrogate the data for him or herself. A trip back to earlier generations of data processing makes it easier to understand the rdbms revolution. Early programs written in Cobol or other so-called 'third generation' languages used a 'data division' of data that could be the property of that program and no other. Even if the data was re-usable, in the sense of being drawn from a library or database, it was arranged hierarchically. The hierarchical database allowed one item only to be the index or key to the information. The index would have to be a unique value, such as an account number, and all other values were dependent upon it, or belonged to it. This imposed a rigid structure on data, geared to the program's primary purpose. The relational database removed the strait-jacket by storing data as a series of ready-made tables. These suggested 'relationships' between data items. The jargon ('third normal form' and 'flat files,' for example) was a frightening smokescreen to a very simple concept. It became possible to combine data in one exercise, by bolting together several tables. The next step was to make this easy to operate for end users who no longer needed to rely on a programmer for one-off reports. EARLY DEVELOPMENTS More than a decade ago, early attempts at query languages, such as Cullinet's Online English made use of natural language parsing, (a branch of artificial intelligence research) with the idea that a user could type in a question in exactly the same way that it would be spoken. This proved little more than an introductory gimmick, because users rapidly look for short cuts. In terms of efficiency, it makes sense for users to learn some sort of structure, as inexpert users can slow the system down by making clumsy searches. By the mid-1980s, SQL had opened the door to non-expert usage of the database, although some training was still necessary. For programmers, the development was even more significant. The existence of a widely-established language made it possible to create programs and entire applications which could interact with a database using SQL as the standard interface. SQL could even bridge the gap between mainframe and Unix applications, by providing a common interface to either. The following is an example of an SQL statement which is looking for all French-speaking employees based in London. The asterisk is a common convention signifying all records. Bracketed lower case words suggest a variable which in practice would be replaced by the variable name in capitals. Actual 'values' are shown in inverted commas: SELECT* FROM (database name eg EMPLOYEES). WHERE (field name eg CITY) = 'LONDON.' AND (field name, eg LANGUAGES) = 'FRENCH'. SQL opened up the possibility of interrogating multiple databases through one application. In the 1990s, the queries are more suggested rather than articulated, using intuitive user-interfaces which lead the users through a series of choices or suggestions, using graphical user interfaces, (GUIs). Agility Business Software is the UK supplier of one such tool, the Quick-SQL query tool, part of a set of development software from the Dutch company, Baan. Quick-SQL does a lot of work behind the scenes, connecting either with commercial databases such as Oracle, Informix, and Sybase, or with Baan's own rdbms, or with the raw commodity of Unix databases, C-ISAM. The user only has to 'point and click' to build a query such as the above, picking a verb such as SELECT, and choosing operators (plus minus equals, and so on) values and field names from lists displayed on the screen. According to Dave Jordan, technical director of Agility, users should have access to any field, indexed or not, and on any database, on the host machine or elsewhere - 'you don't have to know the name of the field, where it is set up, or even what machine it's on. There is usually an English-like description of a field somewhere which acts as a dictionary for access,' he says. The graphical user interface has outdated the original query language, but it enacts the spirit if not the word of the early pioneers. Images and speech, the most natural interfaces for information access, promise to be the next stage of evolution.</p>
		</main>
</body></html>
            