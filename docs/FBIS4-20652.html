<!DOCTYPE html>
<html lang="en-US"><head>
		<meta charset="UTF-8">
		<title>FBIS4-20652</title>
	</head>
	<body>
		<main>
			<p>Conceptual   Aerospace Design  <H4>  Aerospace Design </H4>  <F P=102> 43070062A Tokyo FUJITSU SCIENTIFIC &amp; TECHNICAL JOURNAL in  English Dec 93 pp 401-413--FOR OFFICIAL USE ONLY </F>  <F P=103> 43070062A </F> <F P=104>  Tokyo FUJITSU SCIENTIFIC &amp; TECHNICAL JOURNAL </F> <F P=105>  English </F> CSO   <F P=106> [Article by Yuichi Sato, Masahito Kawai and Hiromichi </F> Yamamoto (Manuscript received June 4, 1993); first paragraph  introductory comment]    [Text] This paper describes a knowledge-based system to  support concurrent design and analysis. The system, DESSIA  (Design Support System for Integrated Analysis) provides  designers with information to analyze a problem and obtain  design outputs by using the expertise accumulated in the system.  The system combines a knowledge base, engineering database, and  program library in an object-oriented expert shell. The system  is flexible and evolutional. Programs and data can be  registered, maintained, and developed with little labor, thereby  providing a systematic framework for constructing and developing  hierarchical databases of programs and data for concurrent  design and analysis.  <H5>  1. Introduction </H5>   The design cycle of complex large-scale structures such as  aircraft and nuclear plants, and that of missions for space  stations and space robots usually has an intricate feedback  structure. For instance, in the case of aircraft the design  cycle begins with a number of design specifications such as  payload mass, flight performance, and cost, followed by a  variety of analyses for factors such as weight, aerodynamics,  and propulsion. These are generally analyzed by different  technical groups, which cooperate in numerous discussions based  on the latest information before finally coming up with a  feasible design concept. An entire project can no longer be  evaluated by a single designer. This makes the designers' most  important task the integration of researcher's expertise,  usually expressed in the form of technical programs and data,  into a single refined design concept. This work is called  concurrent design and analysis. This paper presents a  knowledge-based system which helps designers to perform  concurrent design and analysis by accelerating communication  between designers and researchers.    Unfortunately, the current computer environment is  insufficiently flexible for easy management and integration of  technical programs and data. Underlying problems hindering  efficiency fall mainly into two groups. First, integration of  basic technical knowledge is typically represented by integrated  engineering programs of different technical groups. For example,  to analyze flight performance, which is often done in terms of  flight range and flight time, at least four engineering  programs--weight analysis, aerodynamics analysis, propulsion  analysis, and flight performance analysis--must be combined. The  resulting large, compound program can be used to analyze how a  change in body structure or engine performance influences flight  performance. The programs, which are developed independently,  are too inflexible to be interfaced. Also, once combined into a  large single program, component programs become very difficult  to maintain. Second, most engineering programs have a number of  input and output data items. They are usually scattered,  redundant, disconnected, and jumbled because of the many  independent groups involved. This wastes huge amounts of memory.  Even worse, it becomes very hard to clarify data relationships  and determine the most appropriate design data from the ocean of  numerical values involved. All these problems restrict the  problem-solving and decision-making capabilities of designers in  the design cycle.    The above problems have been known for more than 20 years at  NASA and the Boeing Aerospace Company, and many systems have  been constructed in an attempt to overcome  them[.sup]1)-5)[/]. Historically, the point that determined  the success of a system was its overall flexibility and  maintainability. Previous approaches in which programs were  connected at the source level or through databases, have been  unsuccessful, mainly because of the inflexible procedural  control structures in compound programs and the difficulty of  ensuring consistent maintenance of compound and component  programs. A few years ago, Boeing Computer Services constructed  a knowledge-based system, called Expert Executive, in which  programs are loosely connected through knowledge bases of  input/output arguments and procedural  information[.sup]6)-8)[/]. The system reportedly works better  than its predecessors. However, it focuses mainly on program  integration and neglects the treatment of massive amounts of  data and its relation to program integration.    This paper describes a knowledge-based system, called DESSIA  (Design Support System for Integrated Analysis), which solves  all the above problems. DESSIA is based on the following:    1) Concurrent management of programs and data    The system separates programs from data as completely as  possible and constructs different tree structures. The program  and data trees are interrelated, and their relationship is  accumulated as interface tables in the knowledge base. The  purpose of this separation is to enable programs and data to be  maintained separately and provide a framework for concurrent  management of programs and data.    2) Semiautomatic program integration    The system provides macrocommands to form a large-scale  compound program by combining programs registered in the program  tree. These commands logically check interface information  stored as cross references between argument names in the  knowledge base. Then, these commands semiautomatically determine  the execution sequence of programs. Programs are not connected  at the source level. Instead, they are connected through input  and output argument names contained in the knowledge base.    3) Optimization of design parameters    The system provides a general purpose optimization method  for  design parameters. Using this function, designers can obtain  optimized design parameters under any constraints. This function  is based on a nonlinear programming method called the complex  method. To exploit the advantage of a concurrent design  environment containing workstations connected through networks,  this function has been extended to run in a distribution scheme.    DESSIA enables comprehensive, synchronized treatment of  programs and data. The program and data trees evolve  independently while preserving their flexibility and  maintainability. At the same time, they are closely  interconnected through a chain of I/O arguments in the knowledge  base.  <H5>  2. Concurrent Management of Programs and Data </H5>   In many of the so-called general-purpose programs, so many  items must be selected to reach a function that the user is apt  to give up before the function is even reached. Item selection  is embedded in such a program inflexibly, making it essentially  a closed compound system. These programs may be powerful for  system use, but procedures are difficult to modify, for example,  by connecting the system to external programs. This difficulty  mainly arises because the system does open argument items in an  interface to other programs. The rationale behind separating  programs and data is to open up program interfaces and construct  independent databases for programs and data.  <H5>  2.1 Interface Table </H5>   Programs and data are separated as follows. In view of the  above-mentioned shortcoming in general-purpose programs, a  program should have only one function. As shown in Fig. 1, all  program input and output arguments are placed outside, and  values are read from the input file and then written to an  output file. The number of I/O files is not limited. We then  provide an interface table between I/O arguments and files. For  example, the total weight input argument is specified by an  input file name and a sequence number in the table. The sequence  number indicates the position of the total weight input argument  in the input file. For array data, DESSIA provides a frame for  which array dimensions are registered.   <FIG ID=JPRS-JST-015L-39A>      Fig. 1. Interface table between I/O arguments and I/O </FIG>   <H5>  2.2 Program and Data Trees </H5>   I/O arguments extracted from the program are distributed and  registered in the categorized data tree (see Fig. 2). If the  data tree has not grown enough to accommodate all I/O arguments,  argument items and category blocks can easily be added. The  aggregation of separated programs constitutes another tree  structure, called a program tree.   <FIG ID=JPRS-JST-015L-39B>      Fig. 2. Data tree; categorized I/O arguments. </FIG>    The values of each argument are accumulated in the data  tree,  which maintains the form of each category block. This block of  actual values is called a category instance in the nomenclature  of object-oriented paradigms. Note that although programs and  data are registered separately in their respective trees, they  are connected through argument names. Values in the data tree  flow along argument names, passing through the interface table  to reach program I/O files.  <H5>  2.3 Effects of Separation </H5>   The separation has the following effects. Assume that  several  programs are registered sequentially in the system (see Fig. 3).  The owner of program X first looks into the data tree and  identifies argument items of program X. If the data tree cannot  manage all the arguments of program X, the owner of program X  extends the data tree. Finally, program X is registered in an  appropriate part of the program tree. This procedure is  repeated. As the number of programs increases, the program tree  and data tree evolve from a course to fine structure and  constitute a domain-specific program library and a  domain-specific engineering database.   <FIG ID=JPRS-JST-015L-40A>      Fig. 3. Sequential registration of programs and </FIG>     As programs are registered sequentially, the system  accumulates program and data interfaces spontaneously through  the data tree. This means that once program X is registered, the  data tree can automatically induce connections of I/O arguments  as shown in Fig. 4. Here, initial connection means that the two  programs share the same input arguments. Final-initial  connection means that the output of one of the two programs is  connected to an input of the other. Of course, the owner of  program X does not know the structure of these interfaces in  advance, but the system knows that argument i is  shared in programs A and X by comparing argument names in the  interface tables defined for these programs.   <FIG ID=JPRS-JST-015L-40B>      Fig. 4. Connections of I/O arguments. </FIG>   <H5>  2.4 Concurrency of Program/Data Management </H5>   A common method of constructing large-scale systems is to  determine the interfaces between modules by designing the module  structure of the system from the beginning, and then implement  each module. This top-down style works quite well when there is  no ambiguity in the system architecture or in any algorithm.  However, it usually lacks flexibility in terms of the ability to  change specifications during implementation.    In contrast, DESSIA accumulates each expert's knowledge on  the program and data trees in terms of domain specific programs  and data from the bottom up. Experts can easily plug in or  connect their own original programs and data into DESSIA without  constraints. Once a program is plugged in, interfaces with other  plugged-in programs are automatically set up through argument  tags in a data tree. Experts can concurrently do their own  design and analysis by using other programs and data in DESSIA.  The only sequential (as opposed to concurrent) procedure in  DESSIA is the plug-in procedure. This procedure can only be done  by one person at a time, because otherwise the data tree would  lack connection information between argument tags.  <H5>  3. Compound Analysis </H5> <H5>  3.1 Construction of a Compound Program </H5>   One of the "natural" ways to construct a large compound  program with several component programs is to manually and  arbitrarily provide interface programs. In contrast, in DESSIA,  compound programs are obtained by "cutting" unnecessary  interfaces that are automatically provided by the system.    In DESSIA, the integration procedure consists of four steps  (see Fig. 5). In step 1, the component programs to be integrated  are selected from the program tree. The system then  automatically connects these programs through the interface  information of arguments. Second, in step 2, the sequence  conditions for program execution are imposed. For example, A &lt;  B in Fig. 5 means that program A is executed before program B.  Similarly, * &lt; E means that program E is executed last. These  sequence conditions automatically cut some of the connections  between arguments. The resulting integrated diagram may still  have logical inconsistencies such as internal loops or competent  connections, which means that several outputs may be connected  to the same input (see Fig. 5). In step 3, inconsistencies are  removed from the integrated diagram by cutting unnecessary  connections. Steps 2 and 3 are iterated alternately, as  required, to make a complete diagram. In step 4, the system  decides the execution sequence of component programs by  following the argument connections in the diagram. The completed  diagram is saved for later use. Note that the removal of  inconsistencies in the diagram currently depends entirely on the  designers' decisions. The system does not automatically  construct an entire diagram unassisted, but presents materials  in real time for the designers to evaluate. Hence the  description "semiautomatic."   <FIG ID=JPRS-JST-015L-41A>      Fig. 5. Compound analysis in semiautomatic program </FIG>     Figure 6 shows a program-integration example for the  analysis  of aircraft flight performance, in which five component programs  are selected. The arrows indicate the output to input  connections of the arguments, and lines without arrows indicate  the input to input connections of the arguments. We impose the  sequence condition that the descent performance program is  executed last; therefore, the output of this program is the  final descent performance. The system then asks which of the two  connections is more appropriate for the total weight of the  descent performance. This is a typical logical inconsistency;  that is, an example of competent connection. The most probable  decision of the designer will be that the total weight of the  ascent performance program is more appropriate because of fuel  consumption. After cutting either of these connections, we  finally obtain a consistent diagram. Of course, if different  conditions are imposed, a different diagram is obtained. When  connecting the same program more than twice or constructing a  highly-hierarchical compound program, we adopt a step-by-step  approach. First, we construct a compound program with different  component programs based on the procedure mentioned above, and  regard it as one component program. We then add new or  previously used component programs to the compound program  repeatedly. This repetition completes the compound program  construction we require.   <FIG ID=JPRS-JST-015L-41B>      Fig. 6. Example of program integration. </FIG>   <H5>  3.2 Management of Compound Data </H5>   Usually, in an engineering program, it is effective to  classify input and output arguments based on their semantic  nature. The effectiveness becomes more evident when dealing with  programs having a hundred input/output arguments or more (see  Fig. 7). Each block is called a category block. As mentioned in  chapter 2, each category block of arguments is distributed and  embedded in the data tree. This can be done in two ways. One way  is to make a new category block in the data tree, and then  register the corresponding arguments. The other is to find a  corresponding category block from among those already registered  in the data tree, and then identify each argument with the  corresponding argument in the category block or add new argument  items to the category block.   <FIG ID=JPRS-JST-015L-42A>      Fig. 7. Example of categorization of massive amount of </FIG>     Actual data for each category block is accumulated in the  form of a category block replica, called a category instance, in  the data tree. The total set of input and output data for each  engineering program can be specified in terms of the combination  of these category instances. (see Fig. 8).   <FIG ID=JPRS-JST-015L-42B>      Fig. 8. Combination of category instances. </FIG>     The categorization avoids redundancy in data. For example,  if  we construct a compound program as shown in Fig. 6, the system  automatically assigns category blocks to each component program,  with the category instances of "structure" expressing the same  data in the data tree. Once a compound program is constructed,  the system retains the connection of programs and the  combination of category instances that relate to this compound  program. This enables us to clarify the interrelationship of  category instances by following the vertical and horizontal  connections of category instances (see Fig. 9). In Fig. 9, the  vertical connections correspond to the combination of category  instances in Fig. 8.   <FIG ID=JPRS-JST-015L-43A>      Fig. 9. Compound program and related combination of </FIG>   <H5>  4. Optimization of Parameters </H5>   DESSIA uses an optimization module to provide the minimum or  maximum values for design parameters such as weight, fuel  consumption, and cost.    Many methods of obtaining the (local) minimum or maximum  value for a multivariable function have been investigated. These  methods are classified into two general groups: mathematical  programming and calculus of variations. These methods are  further categorized into linear and nonlinear types (see Fig.  10). The mathematical programming methods include the notable  Karmarker method[.sup]9)[/], which is linear, and the  well-known Davidson, Fletcher, Powell (DFP)  method[.sup]10)[/], which is nonlinear. The calculus of  variations methods include Kalman's controller design  formulation[.sup]11)[/].   <FIG ID=JPRS-JST-015L-43B>      Fig. 10. Classification of optimization methods. </FIG>     We decided that the complex mathematical programming  method[.sup]12)[/] is the most appropriate optimization  technique for DESSIA because of the following reasons:    1) Large-scale systems are, in general, very complicated  nonlinear objects, and therefore, it might not be possible to  describe them analytically.    2) Usually, to obtain optimal values, a number of  constraints  expressed by equality and inequality must be taken into account.    3) The evaluation function of optimization is not  necessarily  described analytically; therefore, we cannot assume that the  evaluation function can be differentiated.    The complex method can be applied to a very wide range of  linear and nonlinear systems, both with and without an  analytical object description. Also, this method can be extended  to distributed computation under an environment of connected  workstations. Therefore, the distributed complex method is  suitable for the environment of concurrent design and analysis.  <H5>  4.1 Distributed Complex Method </H5>   Let us consider the following optimization problem: Minimize  an evaluation function f (x[.sub]1[/], ..., x[.sub]n[/])  of n independent variables under the following inequality  conditions:     Using the complex method, the main procedure for the above  optimization problem is as follows:    1) Take n + 1 points in an n-dimensional space.    2) Find n + 1 better points from the previous n + 1 points  by  calculating the evaluation function at each point.    3) Repeat step 2 until the n-dimensional polyhedron  described  by the n + 1 points shrinks to a small region.    In the complex method, inequality conditions (1) are  transformed into penalty functions P[.sub]k[/] which take  the value of 0.0 when conditions (1) are satisfied, otherwise,  they take a very large positive value. Then, the evaluation  function f is modified by adding P[.sub]k[/]:    S = f + _e_ over k P [.sub]k[/] (2)    In the complex method, the modified evaluation function S is  minimized instead of f. If the maximum of f is needed, the sign  of f is inverted. The flowchart of the complex method is shown  in Fig. 11. Each one-dimensional search is carried out by means  of distributed computation, and the maximum degree of  distribution is n when the number of independent variables is n.   <FIG ID=JPRS-JST-015L-44A>      Fig. 11. Flowchart of complex method. </FIG>   <H5>  4.2 Example Calculation </H5>   We applied the distributed complex method to obtain an  optimum path for a manipulator of the Experimental Test  Satellite VII (ETS-VII), which is to be launched in  1997[.sup]13)-15)[/]. Figure 12 shows a computer graphics  model of this satellite. The most serious control problem  regarding the ETS-VII is how to minimize attitude disturbances  due to manipulator movements so that the communication link is  not broken. This problem is solved by finding a manipulator path  which minimizes or locally minimizes attitude disturbances.   <FIG ID=JPRS-JST-015L-44B>      Fig. 12. ETS-VII concept. </FIG>     As an evaluation function, we take the maximum of  feedforward  angular momentum L[.sub]Wff[/] for the momentum wheels (see  Fig. 13 for the notation). L[.sub]Wff[/] is given by:    <FIG ID=JPRS-JST-015L-44C>      Fig. 13. Coordinate definition. </FIG>     where    Q[.sub]x[/] = max (0  t  t[.sub]F[/]) |  L[.sub]Wffx[/] (t)/M[.sub]x[/] |,    Q[.sub]y[/] = max (0  t  t[.sub]F[/]) |  L[.sub]Wffy[/] (t)/M[.sub]y[/] |,    Q[.sub]z[/] = max (0  t  t[.sub]F[/]) |  L[.sub]Wffz[/] (t)/M[.sub]z[/] |,(5)    The constraints are limits for each joint angle:    _th_min i  _th_[.sub]i[/]  _th_ max i, i = 1, ...,  6  (6)       ------------------------------------------------------------------------------  |Table 1. Initial input for optimization                                     |  ------------------------------------------------------------------------------  |          |_th_    |_th_    |_th_    |_th_    |_th_    |_th_    |  |          |[.sub]1    |[.sub]2    |[.sub]3    |[.sub]4    |[.sub]5    |[.sub]6    |  |          |[/]    |[/]    |[/]    |[/]    |[/]    |[/]    |  ------------------------------------------------------------------------------  |Initial j-|0.0       |0.0       |0.0       |0.0       |0.0       |0.0       |  |oint angl-|          |          |          |          |          |          |  |es (deg)  |          |          |          |          |          |          |  ------------------------------------------------------------------------------  |Final joi-|0.0       |-77.0     |60.0      |105.0     |90.0      |0.0       |  |nt angles |          |          |          |          |          |          |  |(deg)     |          |          |          |          |          |          |  ------------------------------------------------------------------------------  |Final tim-|3.667     |                                                      |  |e t[.sub]F |          |                                                      |  |[/] (s)|          |                                                      |  ------------------------------------------------------------------------------      The initial inputs for the optimization are the initial and  final manipulator positions, and the movement time  t[.sub]F[/]. In general all paths connecting the initial and  final positions should be checked to obtain the exact optimum  path. However, we restrict the search region to a feasible path  set in which each joint is assumed to follow a trapezoidal  velocity pattern (see Fig. 14). The acceleration time  t[.sub]Ai[/] and the deceleration time t[.sub]Di[/] are  independent variables of the complex method. Since the ETS-VII's  manipulator has 6 degrees of freedom, the maximum distribution  degree is 2 x 6 = 12.    <FIG ID=JPRS-JST-015L-45A>      Fig. 14. Joint velocity pattern. </FIG>    We set the physical parameters of the ETS-VII as follows:  manipulator mass = 100 kg; manipulator length = 2 m; satellite  main-body mass = 2 tons; and m[.sub]xx[/] = 5,000  kgm[.sup]2[/], m[.sub]yy[/] = 2,000 kgm[.sup]2[/],  m[.sub]zz[/] = 5,000 kgm[.sup]2[/] for the satellite's  main-body inertia.    Table 1 shows the initial inputs for the optimization. The  initial and final manipulator positions are shown in Fig. 15.  The result of the optimization is summarized in Table 2. We used  12 S-4 workstations for the optimization (see section 5.2 for  details). When the procedures were distributed between 12  workstations, the computation time was reduced to about  one-tenth of the time when only one workstation was used. In  this optimization, there was no delay associated with the  communication link because only a few bytes of data were  transmitted through the ethernet cables.       Table 2. Result of optimization                  Joint    Joint 2   Joint 3   Joint 4   Joint 5   Joint    S                 1                                                6   Initial        1/3      0.5 - E   0.5 - E   0.5 - E   0.5 - E   1/3      1.04  t[.sub]Ai[/]   Initial        2/3      0.5 + E   0.5 + E   0.5 + E   0.5 + E   2/3      E =  t[.sub]Di[/]                                                              0.01   Optimized      1/3      0.1341    0.4963    0.4933    0.4928    1/3      0.2265  t[.sub]Ai[/]   Optimized      2/3      0.4867    0.5066    0.5042    0.5028    2/3  t[.sub]Di[/]   t[.sub]Ai[/]  and  t[.sub]Di[/]  are  normalized  by  t[.sub]F[/]   M[.sub]x[/] =  M[.sub]y[/] =  M[.sub]z[/] =  40 Nms.     <FIG ID=JPRS-JST-015L-45B>      Fig. 15. Initial path and optimized path </FIG>     As shown in Fig. 15, the optimized path brings the tip of  the  manipulator toward the center of mass of the satellite's main  body and then curves it away to the final position. This is  physically reasonable and holds very well in almost any  situation.  <H5>  5. Implementation </H5> <H5>  5.1 System architecture for program/data management </H5>   Considering the easy realization of the system architecture,  we have adopted an object-oriented expert shell to implement the  system. We used ESHELL/X on UTI-LISP developed at Fujitsu to  implement the first version of DESSIA on a mainframe computer.  We then converted the system for SPARC stations using the  commercial expert shell "ART" on Common Lisp.    The basic idea of object-oriented systems is to define the  "object," which is a unit composed of methods and properties,  and create an algorithm by sending messages between objects.  There are two levels of objects: class-level objects and  instance-level objects. Class-level objects can be copied as  instance-level objects dynamically. In DESSIA, the components of  the program and data trees are expressed by instance-level  objects produced by class-level objects, and the interfaces  between programs and data are represented by "slot values"  which are ready for the connection. Each time programs and data  are registered in the system, the corresponding class-level  objects produce instance objects and append them to the program  and data trees.    Figure 16 shows the class structure for program/data  management. The classes are categorized into three groups: the  program manager group, compound program/data manager group, and  argument manager group. They are further divided into resident  classes and others. The core of the system currently consists of  more than 20 class-level objects and about 150 methods.   <FIG ID=JPRS-JST-015L-46A>      Fig. 16. Class structure for program/data </FIG>   <H5>  5.2 System architecture for distributed complex method </H5>   In general, there are two methods for distributed  computation: tightly coupled and loosely coupled. In DESSIA, we  assume an environment consisting of workstations connected by  NFS. Therefore the distributed complex method was realized using  a client/server model with UNIX's IPC (Interprocess  Communications). Figure 17 shows the concept of the distributed  computer environment for DESSIA. The manager host is the  workstation which manages the local host workstations. A local  host is a workstation which runs a distributed process. The  terminal host is the workstation used to enter DESSIA and define  an optimization calculation. In general, the manager host and  terminal hosts also function as local hosts. Also, any local  host can become a terminal host for a different user.   <FIG ID=JPRS-JST-015L-46B>      Fig. 17. Client/server model for optimization in </FIG>     The design specifications for the distributed complex method  are as follows:    1) M processes can be distributed between N local hosts. (M  can be greater than N in general).    2) Users can register other workstations as local hosts.    3) Users can easily register optimization modules at any  terminal host using the `plug-in' procedure of DESSIA.    4) Program/data management in DESSIA can be done on any  terminal host, and the concurrency of program/data editing is  handled by the manager host.    Based on these specifications, we realized the following  client/server processes:    1) Host Manager (HM): a server process that runs on the  manager host.    2) Local Host Manager (LHM): a server process that runs on  each local host and is activated by HM.    3) Prototype Process Manager (PPM): a server process that  runs on the manager host and managing PPs and is activated by HM.    4) Prototype Process (PP): an object process that runs on  each local host and is activated by LHM.    5) Process (P): a process that runs on each local host,  executes an actual distributed object, and is activated by PP.    6) Client Process (CP): a client process that runs on the  terminal host and is primarily activated by a user as required.    Initially, DESSIA is awakened on the manager host by a user.  Then, HM is activated on the manager host and LHM is activated  on each local host. HM and the LHMs then wait for a message from  a terminal-host's client process. A user then enters DESSIA at a  terminal host and wakes up a client process, which then does the  following:    1) Asks HM to wake up PPM and PPs through the LHMs.    2) Asks PPM to set the initial inputs for each PP.    3) Asks each PP to wake up Ps. (The total number of Ps is  M.).    4) Waits for a computed result from each P.    5) Releases the finished Ps.    We assume that all terminals and local workstations have the  same versions of OS and libraries. If the versions are not the  same, execution modules for the complex method must be  recompiled beforehand at a local workstation.  <H5>  6. Conclusion </H5>   We have analyzed some of the problems in the computer  environment surrounding designers whose role is to integrate the  programs and data that express the expertise of researchers. We  have developed a knowledge-based system to support these  designers.    This system is evolutional. As the programs and data are  registered, the program and data trees in the knowledge base  become proportionally larger. Combining programs in the program  tree enables a large-scale compound program to be built without  programming. The resultant execution data is arranged in the  data tree, which can be regarded as an engineering database  interconnected with a chain of I/O arguments.    We introduced the complex method into DESSIA as an  optimization tool to obtain the maximum or minimum of any  nonlinear function. We extended this method into a distributed  complex method to suit the network environment. Preliminary  experiments showed that the distributed complex method reduced  the computation time almost in proportion to the number of  workstations.    Improvements planned for the near future include:    1) Implementation by C[.sup]++[/]    In view of the current trend for object-oriented  programming,  implementation by C[.sup]++[/] instead of a Lisp-based expert  shell will provide more flexibility and compatibility.    2) Scheduling of distributed computation    Computation efficiency will be improved by scheduling the  degree of distribution based on the workstations' CPU power and  occupancy.    3) Graphical human-machine interface    A flexible graphical HMI such as GUI Builder will make it  relatively easy to construct large-scale compound programs on  DESSIA, as shown in Fig. 18.   <FIG ID=JPRS-JST-015L-47A>      Fig. 18. HMI image for DESSIA </FIG>   <H5>  7. Acknowledgment </H5>   We would like to thank Mr. Koichi Matsusima and Mr. Masao  Naka of the National Aerospace Laboratory for the many valuable  discussions we had with them.  References    1) Glatt, C. R., Hague, D. S., and Watson, D. A.: DIALOG: An  Executive Computer Program for Linking Independent Programs.  NASA CR-2296, 1973.    2) Glatt, C. R., and Hague, D. S.: ODIN: Optimal Design  Integration System. NASA CR-2492, 1975.    3) Wilhite, A. W., and Rehder, J. J.: AVID: A Design System  for Technology Studies of Advanced Transportation Concepts. AIAA  79-0872, 1979.    4) Walker, W. J., Vos, R. G., Price, G. A., and Brogren, E.  W.: IAC Executive summary. NSA CR-175196, 1984.    5) Meyer, D. D.: Development of Integrated Programs for  Aerospace-Vehicle Design (IPAD) Reference Design Process. NASA  CR-2981, 1984.    6) Chalfan, K. M.: An Expert System for Design Analysis.  Workshop on Coupling Symbolic and Numerical Computing in Expert  System, 1985.    7) Chalfan, K. M.: A Knowledge System Which Integrates  Heterogeneous Software for a Design Application. Proc. JSST Int.  Conf. Tokyo, 1986.    8) Chalfan, K. M.: A Generic Tool for Integrating Software  Components. Proc. CIPS, Edmonton, 1987.    9) Karmarker, N. K.: A New Polynomial-Time Algorithm for  Linear Programming. Proc. from the ACM Symp. Theory Computer,  1984, pp 302-311.    10) Fletcher, R., and Powell, M. J. D.: A rapidly convergent  descent method for minimization. J. Optimization Theory  and Applications, 6, pp 163-168 (1963).    11) Kalman, R. E.: Contributions to the theory of optimal  control. Vol. Soc. Mat. Mex.,, 5, pp 102-119 (1960).    12) Box, M. J.: A New Method of Constrained Optimization and  a Comparison with other Methods. Computer Journal, 8,  1, (1965).    13) Oda, M.: Space Robotics On-Orbit Experiments by ETS-VII.  (in Japanese), Proc. 9th RSJ Annual Conf., 1311, 1991, pp 75-78.    14) Oda, M., Wakabayashi, Y., Ichikawa, S., Imai R., and  Anzai, T.: ETS-VII, The World First Telerobotic Satellite  (Mission and its Design Concept). Proc. 1992 i-SAIRAS, 1992, pp  307-315.    15) Sato, Y., Hirata M., Nagashima, F., Maruyama, T., and  Uchiyama, T.: Reducing Attitude Disturbances while Teleoperating  a Space Manipulator. Proc. 1993 IEEE Robotics and Automation  Conf., 3, 1993, pp 516-523.</p>
		</main>
</body></html>
            