<!DOCTYPE html>
<html lang="en-US"><head>
		<meta charset="UTF-8">
		<title>FBIS4-22982</title>
	</head>
	<body>
		<main>
			<p>OFFICIAL USE ONLY  <F P=103> 937G0083A </F> <F P=104>  Kiev KIBERNETIKA I SISTEMNYY ANALIZ </F> <F P=105>  Russian </F> CSO   <F P=106> [Article by V.V. Gusev, T.N. Galagan, V.V. Yaremenko; UDC </F> 681.3.06]    [Text]  <H5>  Introduction </H5>   We would like to emphasize certain aspects of the history of  the development of modeling languages in accordance with the  accepted classification of its stages and trends.[.sup]1[/]  Modeling languages are recognized to have made a significant  contribution to the development of programming languages.    By the late 60's, mainly due to the authors of SIMULY-67,  requirements were formulated for universal programming languages  so that they could be used to model systems with discrete  events. In the 70's, this achievement sparked subsequent efforts  to enrich and combine languages in order to include new classes  of systems which could be modeled. An example is combined  (discrete-continuous) systems with a dynamically tuned  structure. The NEDIS system[.sup]2,3[/] was developed by  Academician V.M. Glushkov to model this type of system, and was  used intensively in dozens of design organizations. This was a  period when modeling language developers were resolving their  internal methodological problems, and their successes in  creating means of generating simulation programs to calculate  the trajectories of systems in some time period derived from  engineering use of pure mathematics.    However, subsequent extensive experience in using the NEDIS  system and user interaction with the system led to the  formulation of a number of critical conclusions (see for example  Reference 4) which reflected new trends in the automation of  design:     -  design was increasingly recognized to be a complex  activity involving simulation and other calculation methods,  with a key role played by methods based on algebraic  description, expert systems, databases, etc.; it was felt that  the transfer and conversion of information in the transition  from one method to another should be completely automated;    -  the languages which were being used did not have the  declarative capabilities to specify the system model, a plan of  statistical experiments, and other formal objects of the design  process as the break was made from an unambiguously understood  method of interpreting them, and thus could not serve as the  basis for evaluation and validation of the properties of the  system and other methods of interpreting the texts of  specifications.       The 80's are characterized by a switch to the development of  integrated design systems distinguished by a certain  completeness of the methods used and a much more convenient user  interface. The more specialized and more stable the area of  application to which they were applied, the better these systems  were. At the same time, these systems were poorly developed. The  problem arose of timely development of specialized systems, and  consequently, the problem of developing the corresponding tools  also arose.    One would hope that a new stage in the development of  languages would lead to the development of the following  capabilities:     -  adaptability to dialects of professional groups of users  (the features of declarability depend substantially on the  ability to use ``small'' languages[.sup]5[/] that closely  correspond to the subproblem to be solved);    -  the ability to support various programming paradigms (in  contrast to publications like References 6 and 7, page 281); for  us, ``supporting a paradigm'' means having the ability to  effectively develop paradigms on the basis of some fundamental  version;    -  the combination of different methods of research and design  in  a single system, that is, based on clearly recognized interfaces  between them;    -  a flexible combination of the processes of interpretation and  compilation.       A language with these characteristics might become an  adequate technological basis for the construction of interactive  integrated systems which are open to expansion with the contents  of interacting functional subsystems, which would share a single  database and differ in their methods of description and  processing.    This article presents a draft of the NEDIS-90 programming  system developed by the authors. The system attempts to solve  some of the aforementioned problems. The following section  presents a brief overview of the system's programming language.  The possibility of using the language for modeling is discussed.  Finally, the current state of work to implement the system and  plans for subsequent development are discussed.  <H5>  Modules </H5>   Programs are assembled from modules, which are compilation  units. In this case a module usually has a more simple structure  than in other languages. In a very simple case the text of the  module looks like a series of operators without any branching.  In the most general case it consists of a sequence of  ``descriptive'' and ``executed'' segments. A module is a  variation on the concept of the block:  &lt;graphic&gt; &lt;/graphic&gt;     The required initial sequence of operators is considered the  unheaded segment EXEC.    The segments GLOB and LOC are intended to describe classes,  objects, procedures, and exceptions. Descriptions of GLOB  segments are public, visible even to other modules. Descriptions  of LOC segments are completely localized to the given module.  Implementation of classes and procedures may be presented in  WHERE segments, and ON segments are intended to describe  procedures of reactions to exceptions.    A module is executed statically in part in the compilation  stage, and partially dynamically in the program. The static  actions are described in INIT segments. The dynamic actions of  the module are divided into preliminary (EXEC segments) and  final (TERM segments) actions for mutual ordering of the  execution of modules in a program.    Segments of any type may be presented in an arbitrary order  which is convenient for the programmer, with the only condition  that they be labeled before they are used.    Descriptions of new concepts have a form similar to that  used  in Pascal:    description = label -- descriptor    Descriptors define the type of the new concept, and may  contain information about its initialization. We limit ourselves  to the simple example of description of a class of complex  numbers, a generator function, and an object of this class:  &lt;graphic&gt; &lt;/graphic&gt;     As we can see, the body of the class of complex numbers in  braces is also a block. In this case it consists only of the  GLOB segment, the descriptions of the fields re and  im, which are visible in the current module beyond  the limits of the body of the class, and which may be used in  generally accepted constructions like z.re.    The generator function block consists only of an unheaded  EXEC segment. Procedure-functions return the object called  result.    In accordance with the concepts of data abstraction the  internal device of class is not considered visible in other  modules, and to define the real part of a complex number we need  to introduce the special function Re(z):  &lt;graphic&gt; &lt;/graphic&gt;     In the first example the class descriptor complex  includes its implementation. Here we demonstrate the possibility  of separate ``preliminary'' description and specification of the  implementation. The key word static is included in  the descriptors of static procedures and objects which do not  change state in the process of program execution.    The example which is presented may be seen as the beginning  of the design of a new specialized language of complex  calculations. The global labels which are introduced in it may  also be used in other modules, for which the current module will  be called contextual.    On the other hand, several initial concepts are used to  specify the current module, for example, the class  real. The list of initial functions for the  programmed module is always defined by a list of contextual  modules indicated for it.    We note that the names of contextual modules are not  included  in the text of the current module and are communicated to the  compiler as a separate parameter. This makes it possible to  organize the programming system so that the selection of a list  of contextual modules, and consequently, the programming  language, is done automatically, proceeding from the  professional profile of the user. Even more interesting is the  ability to use in a module various sets of contextual modules if  the system of labels that they introduce is invariant. As a  result, one can state that this module is no more than some  specification of a system or task, and it may have several  interpretations. For example, for a single description of an  electronic device, placing it in a different context one can  synthesize a structural schematic, verify that certain limits  are met, execute logical modeling, etc.    As a result of compilation of the initial module in  accordance with some list of contextual modules one develops a  new contextual module which includes both object code for the  program assembler and syntax compiler tables to process future  modules. The module may not introduce new global definitions. In  this case one will obtain a common object module whose purpose  is to execute some data processing in the program which includes  it. On the other hand, a module may be completely intended to  introduce labels of concepts of some specialized language, and  may not include executable codes.    Any contextual module ``remembers'' the names of its parent  contextual modules. Thus, the library of contextual modules is  constructed as an oriented acyclical graph. In order to assemble  a program, one does not need a project-file; it is  sufficient to indicate the name of some key (junior) module, and  the remaining modules, its ancestors, will be included using  references to the parent modules.    The execution of modules in a program is ordered in  accordance with the following recursive rule: the execution of  the EXEC and TERM segments of a given module begins with the  one-time execution of the EXEC segments and ends with the  one-time execution of the TERM segments of parent modules. Thus,  the execution of any module in a program begins when the  necessary tuning has already been done, and after it is  finished, completion processing automatically follows.  <H5>  Built-In Modules and Mobility </H5>   There is a set of built-in contextual modules which are  terminal nodes of the oriented graph of the library, and  initially fill it. They describe the description tools of a  machine (real or virtual) to implement the programming system.  For example, the aforementioned class real and the  operations corresponding to it are components of a sublanguage  defined by the built-in contextual module ARIPH. Below we  present several other built-in modules:  &lt;graphic&gt; &lt;/graphic&gt;     As one can see, we do not consider built-in data types,  operations, or even control structures to be part of the basic  NEDIS-90 language. Information about them is not concentrated in  the compiler, and it is relatively easy to change its  orientation to another machine language.    The implementation machine is oriented toward the C  language,  which defines the content of the built-in contextual modules. A  system programmer making the first steps into an ``empty''  system is in the position to use a C-like programming language.  The machine which has been selected is very close in its  capabilities to a traditional processor and generally accepted  operating system. In its orientation toward direct generation of  codes the built-in contextual modules do not require significant  corrections, but rather implementation of a more exotic logic  deduction processor or LISP processor for an implementation  machine.    In any case our problem is to compare an implementation  machine as closely as possible to the filling of built-in  conceptual modules. Then the programming system can be used to  adjust to the area of application, beginning with the machine  command level. This tuning can be done as effectively as  possible. This does not require any interpreter or a library of  system functions created outside the programming system with  another technology.    Nonetheless, the problem of the mobility of a software  language, if it is posed, may be solved by reprogramming the  secondary contextual modules which it specifies on the basis of  built-in machine-dependent modules.  <H5>  Data Types </H5>   A module may define three varieties of objects: static,  dynamic, and stored. Static and stored, and sometimes dynamic  objects, are initialized at the compilation stage. INIT segments  may include algorithms of any level of complexity and freely  modify their state. However, later, at the program execution  stage, static objects may not be modified, and are considered  constants. Complete monitoring of attempts to modify constants  is implemented, as is monitoring of types, statically.    Constants of typical built-in classes (whole numbers, lines,  etc.) are considered static objects, and their traditional  labels are visible in any module. However, due to the reloading  which is permitted they may be used like any other identifiers,  in particular, to label user class objects.    By the beginning of module execution stored objects  automatically reset the state acquired as a result of the  previous run of the module in this or another program. There is  no access to stored objects outside the module in which they are  defined, and consequently, control of their integrity is  completely in the hands of the module developer. Stored objects  are primitive tools for constructing subsystems and database  control languages.    All objects have a life time which is not directly linked  with the exit from the description block. The safety of pointers  is insured by trash collection tools. This is particularly  important for areas of application associated with delayed  (lazy) calculations, when access to objects may be preserved  after one leaves their description block due to established  dependences.  <H5>  Effectiveness Issues </H5>   The NEDIS-90 language is oriented toward the generation of  effective programs on the level provided by C language compilers.    The experience of constructing complex programs like  compilers or modeling programs has shown that they frequently  include a large initial tuning code.[.sup]8[/] In order to  reduce initialization expenditures, one could implement  statically defined calculations in the compilation phase;  however, generally used high-level languages do not permit one  to do this, limiting static calculation to built-in types and  operations. The introduction of INIT segments makes it possible  to generate a special program of arbitrary complexity to  initialize the data of the object modules. An optimization  examination recognizes statically defined expressions in all  other segments and moves them into an initialization program.    Object-oriented programming has stimulated users to develop  a  large number of small procedures. Overhead in the execution of  calls and context switching can be avoided in some cases if one  uses an open procedure substitution. Thus, the majority of  procedures presented in the examples are better defined as open  procedures.    Pointers have a rather complex structure in NEDIS-90 to  provide tools for dynamic monitoring of types, usually in  connection with virtual procedures. However any time it is  possible the compiler uses the simple format of pointers in C.    Finally, the closeness of built-in contextual modules to  machine implementation tools also makes it possible for the user  to completely control the implementation method of  problem-oriented languages.  <H5>  Introduction of Labels and Their Possible Forms </H5>   NEDIS-90 has rather traditional tools for the development of  problem-oriented data types and operations based on  object-oriented programming techniques (classes as user types,  encapsulation, class inheritance, virtual procedures). What is  unusual is the ability to develop problem-oriented labels for  them. Actually the language may be seen as a metasystem which  permits one to define the syntax of almost any system of labels  used in some professional language.    There is no need to use the Backus-Naur metalanguage or  similar metalanguages to give the form of labels. The proposed  method is more like compilation of a syntax map on the left side  of the description:  &lt;graphic&gt; &lt;/graphic&gt;     Alphanumeric, sign, and literal lexemes are differentiated.  Alphanumeric lexemes begin with letters or numbers. Literal  lexemes are written as sequences of graphic symbols in quotes.  Lexemes of all three types are equivalent and have no predefined  role.    Labels consist of arbitrary sequences of lexemes of any  type,  as well as, if necessary, specifications of parameters in square  brackets. There are no limits on the order of introduction of  lexemes or parameters. Functions may have a canonical form, the  form of an infix operation, or any other form. One can assign  operation priorities.    Labels of functions may include specification of default  values of parameters, variable lists of single-type parameters,  and the parameter-generators of structural objects. In all cases  complete static monitoring of types is provided.    Let us present an example of the description of a function  with a variable list of parameters.  &lt;graphic&gt; &lt;/graphic&gt;     and a call of the described function:    min(3, 5, 2, 11);    The list of arguments 5, 2, and 11 forms a file which  corresponds to the formal parameter y. The expression y#  calculates the size of the file.    One can reload labels, changing both the type of arguments  and the type of result. For example, both varieties of  assignment are provided by the built-in module ARIPH  &lt;graphic&gt; &lt;/graphic&gt;     which makes it possible to make the following assignment: i  =  j = k.    The compiler considers the actual system of implicit  transformations, which is partially built-in, and which is  partially determined by the user program, for example, with a  function which generalizes a real to a complex number:  &lt;graphic&gt; &lt;/graphic&gt;     Parameters can be passed by value, by reference, or by name.  The simplest argument, in the form of the name of a complex  variable, can correspond to the following types of parameters:  &lt;graphic&gt; &lt;/graphic&gt;     Let us examine an example of the definition of a loop  operator using all three forms of parameter passing:  &lt;graphic&gt; &lt;/graphic&gt;     Implementation of the FOR operator uses a call to the  procedure UPTO with an argument expression in the form of a call  of the LOOP procedure, the simplest built-in variety of an  infinite loop. This case is interesting in that the expression  is parametric. The corresponding formal parameter, which is  labeled as greater, is the object of the built-in  class of outputs (exceptions) and is used as a marker to leave  the loop.    The definition of the UPTO operator is very simple:  &lt;graphic&gt; &lt;/graphic&gt;     The body of this procedure introduces the exception  break. Its generation within the parameter-procedure  body leads to immediate exit with completion of the  reaction procedure (which in this case is empty).    Expressions with parameters, or lambda variables, are  especially important in programming applications with functional  or logical styles of programming.    The examples which have been presented use tools which are  defined by built-in contextual modules, and which demonstrate  the ability to design one's own programming language. They were  selected so that they would be understandable for programmers,  and would not require a great deal of explanation, as in the  case of a modeling language or another problem-oriented language.    The basic language is the only thing which should be studied  by all users in common. We note that it does not include  built-in classes and procedures, and serves only to develop  problem-oriented languages. Thus, it is significantly smaller  than a number of other programming languages. At the same time  the use of a problem-oriented language requires additional study  of specific concepts which are defined by the corresponding  contextual module. Of course this is also true for built-in  contextual modules.    Can one consider NEDIS-90 a true metasystem? Actually, it  has  serious limits in the construction of user languages. In  particular, the following are impossible:     -  proposal of one's own compilation unit structure;    -  changing the format of descriptions;    -  controlling the method of separating literals in the text of  a  module, as well as other labels with an a priori sense, as  occurs, for example, in languages with variables without  preliminary declarations;    -  input of one's own rules for the visibility of labels.       Attempts to introduce such tools are possible,[.sup]9[/]  but may disrupt the relative simplicity of the language and the  illusion of preserving traditional approaches.  <H5>  Opportunities for Use in Modeling </H5>   NEDIS-90 was developed with constant checking of its  elements  for correspondence to the problems of designing various  problem-oriented languages, especially for automation of design.  The authors were interested in the modeling of combined, or  discrete-continuous systems. Our problem was to provide the new  system with the ability to construct a modeling language while  conserving the main advantages of the old NEDIS language:     -  event and process methods of constructing models;    -  description of continuous dependences in the form of common  differential equations;    -  no limits on the possibility of alternating fragments which  establish discrete and continuous dependences if the internal  logic of the text of the model requires this;    -  automatic ordering of the solution of the Cauchy problem  (equation sorting), in spite of the modular construction of the  program and dynamic reconfiguration of the modeled system;    -  dynamic generation of continuous blocks with common tools for  generating copies of classes.       At the same time, the new system has a number of advantages.  Developing individual languages (to control experiments, process  results, etc.) one can divide a program into functional modules,  as is proposed in Reference 10.    The process method of constructing models is based on the  built-in concept of a coprogram with an explicit naming system.  In addition to the generally accepted resume operator  to switch coprograms, the built-in contextual module TASK also  defines an operator of asynchronous execution of procedures in  the stack of the indicated coprogram:    plan [*task] for [proc] -- static proc;    The plan operator makes it possible to model  interruption of coprograms. When a coprogram is reset the  indicated procedure is executed first, then after it is normally  completed it returns to the interrupt point. Generation of an  exception makes it possible to move down in the activations  stack to the trap with the specified reaction.  <H5>  State of Development and Future Goals </H5>   At publication, the implementation of the NEDIS-90 compiler  with generation of programs in C for IBM PC compatible computers  is complete, and is being comprehensively tested. The main  difficulty has been implementation of a dynamic syntax analyzer  which is capable of adapting to the intervention of users in the  definition of the grammar.[.sup]11[/]    Our initial plans were to place limits on the language  defined by the user to insure irreversible recognition. It  turned out that to formulate these limits and to verify their  execution was too difficult. (Footnote) (One should not confuse  this with the possibility of verifying[.sup]12[/] that the  grammar belongs to class LR(k) for a given k.) Moreover, we  always found interesting problem-oriented languages in conflict  with the working draft of the limits system. Thus, the final  version of the syntax analyzer provides parallel examination of  the alternatives using a bottom-up method. Consequently, the  implementation of several potential useful properties of the  language have been simplified, for example, reloading of the  labels of functions by the type of results. At the same time,  this recognition scheme is very sensitive to the number of  implicit transformations given; because there are not goals it  tries to use them an excessive number of times. There are two  main types of errors for the syntax analyzer:     -  unrecognized syntax construction;    -  ambiguous recognition.       The latter is the analog of a ``multiply described  identifier'' error in other languages, and may be the result of  incorrect assignment of the system of implicit transformation or  reloading of labels.    Unfortunately, the resulting speed of recognition is on the  order of 1200-3600 lines per minute on a computer with a clock  speed of 12 MHz, which is not as high as in industrial compilers.    The next step should be development of an interactive  technological programming environment in NEDIS-90. Its  distinguishing feature should be openness. This means that any  new program should not differ from pre-existing components such  as the compiler, dynamic debugger, or text editor. All of them  must be controlled by a uniform user interface and have access  to separate control data of the environment. This requires a  special assembler which is capable of adjusting pointers with a  consideration of the location of resident programs and  data.[.sup]13[/] In order to free the constructors of  interactive applications from the routine need to create syntax  analyzers for user input, it is proposed that the compiler and  assembler be implemented in the form of a special built-in  contextual module.    One of the most interesting issues for discussion, which is  beyond the scope of this article, is the use of the NEDIS-90  language to construct languages in the declarative style of  programming and its use in artificial intelligence. Let us  briefly outline the basic points of the plan to expand the  language by introducing built-in tools for the processing of  terms, objects of a special class whose values are coded by  expressions.    Compared to a formal parameter like a term, an argument  expression is passed to the compiler only in the syntax analysis  phase. Instead of generating machine commands the recognition  tree switches to the program execution stage, where it can be  converted with built-in term operations. By programming some  ``deduction machines'' in a number of cases one can obtain the  solution of a problem as a result of pure ``transcription'' of  terms.    At the same time, one should provide a built-in function to  generate a procedure segment using a term value if this  corresponds to the calculated expression. In conjunction with  the developed opportunities to use stored data, this makes it  possible for the user to actively define the balance of  compilation and interpretation processes.    The properties of the procedural paradigm, which is the  basis  for built-in contextual modules, should not prevent the  development of other styles of programming. For example,  disruption of an assignment is not a pre-defined operation for  objects of any class. It is introduced only for object-variables  of standard types and when necessary can be described explicitly  for user classes of objects. Procedures (and terms) will be seen  only as built-in varieties of the concept of a generalized  function with a predetermined interpretation. The user has the  right to define his own classes of functions.    At present the problem of the conflict of functional  completeness of term processing tools and the limits which  proceed from the requirements of static control of types is  being examined.  <H5>  Conclusion </H5>   The idea of a universal programming language had long been  an  attractive one, until it became clear that a key issue was not  the infinite increase in the number of tools, but a  generalization of expansion methods and specialization. The  practice of specialization is now omnipresent, but it does not  exist as a technology supported by a single programming system.    The NEDIS-90 programming language presented here is intended  to create program systems with certain problem-oriented  languages. This is a common compiled object-oriented language  providing the possibility of constructing user types and  operations on the basis of known types and operations. It  includes the opportunity to define a language syntax suited to  the problem area, but cannot itself contain any built-in type  and operation descriptions. Implementation of a problem-oriented  language is registered in the program system as a contextual  module. The basis consists of built-in contextual modules. They  correspond to the level of tools of the implementation machine.    The initial module may contain calculation fragments which  are as complex as desired, and these are executed at the  compilation stage. As a result, all objects described at the  module level may be initialized at compilation time. The  language permits work with stored objects to program database  control tools.    A special built-in contextual module defines the primitives  of the coprogram implementation needed to construct modeling  languages and parallel execution of programs.  References    1. P. Kiviat, ``Simulation, Technology and Decision  Process,'' ACM TRANS. MODELING AND COMPUTER SIM. Vol. 1 No. 2,  1991 pp 89-98.    2. V.M. Glushkov, V.V. Gusev, T.P. Maryanovich, et al.,  Programmnyye sredstva dlya modelirovaniya  nepreryvno-diskretnykh sistem [Software Tools To Model  Continuous-Discrete Systems], Kiev: Nauk. dumka, 1975 152 pp.    3. S.S. Azarov, V.V. Gusev, T.P. Maryanovich, et al.,  ``Simulation with Tools in the NEDIS and GASP-IV Systems,''  KIBERNETIKA No. 3, 1980 pp 35-50.    4. V.V. Kalashnikov, ``Aggregative Systems: Modeling,  Mathematical Analysis, Simulation,'' SYST. ANAL. MODEL. SIM.  Vol. 8 No. 7, 1991 pp 507-514.    5. E. Ipser, ``Exploratory Language Design,'' ACM SIGPLAN  NOTICES Vol. 27 No. 4, 1992 pp 41-50.    6. J. Placer, ``Integrating Destructive Assignment and Lazy  Evaluation in the Multiparadigm Language G-2,'' ACM SIGPLAN  NOTICES Vol. 27 No. 2, 1992 pp 65-74.    7. J.A. Goguen, J. Meseguer, ``Models and Equality for  Logical Programming,'' LECT. NOTES COMP. SCI. Vol.250, 1987 pp  1-22 (Russian transl. in book Matematicheskaya logika v  programmirovanii: Sb. statey [Mathematical Logic in  Programming: A Collection of Articles], Moscow: Mir, 1991 pp  274-310).    8. M. Sabatella, ``Lazy Evaluations of C++ Static  Constructors,'' ACM SIGPLAN NOTICES Vol. 27 No. 6, 1992 pp 29-36.    9. H. Christiansen, ``Adaptable Grammars,'' ACM SIGPLAN  NOTICES Vol. 25 No. 11, 1990 pp 35-44.    10. D. Sanderson, R. Sharma, R. Rozin, et al., ``The  Hierarchical Simulation Language HSL: A Versatile Tool for  Process-Oriented Simulation,'' ACM TRANS. MODELING AND COMPUTER  SIM. Vol. 1 No. 2, 1991 pp 113-153.    11. S. Cabasino, P.S. Paolucci, G.M. Todesco, ``Dynamic  Parsers and Evolving Grammars,'' ACM SIGPLAN NOTICES Vol. 27 No.  11, 1992 pp 39-48.    12. D. Knuth, ``On the Translation of Languages from Left to  Right,'' INFORM. AND CONTROL Vol. 8, 1965 pp 607-639 (Russian  transl. in book Yazyki i avtomaty. Sb. statey  [Languages and Automata. A Collection of Articles], Moscow: Mir,  1975 pp 9-42.    13. N. Wirth, ``The Programming Language Oberon,''  SOFTWARE-PRACTICE AND EXPERIENCE Vol.18 No. 7, 1988 pp 671-690.</p>
		</main>
</body></html>
            