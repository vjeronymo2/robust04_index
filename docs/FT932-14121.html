<!DOCTYPE html>
<html lang="en-US"><head>
		<meta charset="UTF-8">
		<title>FT932-14121</title>
	</head>
	<body>
		<main>
			<p>930420 FT  20 APR 93 / Survey of A-Z of Computing (26): Easier ways to build systems - . . . For Yourdon ED YOURDON, a pioneering American computer scientist, gave his name to a method for breaking down the design of a computer system into a set of components and the relationships between them. The Yourdon Method is, however, only one among many structured approaches to building computer systems - all of which fall under the general heading of computer-aided software/systems engineering, (CASE). As long ago as the late 1960s, computer scientists recognised that building information technology systems of any size was a complex task. But they also saw that it could be simplified if it were viewed as an engineering discipline rather than an arcane craft. This important breakthrough in thinking spawned a succession of 'methodologies' - each of which claims to make systems building at least more manageable, if not easier. Most software in the past was produced in an informal environment where much was left to the individual programmer or systems designer. This was unsatisfactory because it often led to complex systems which could only be understood by those who built them. If a programmer or designer left, maintenance became a problem. Starting in the military and aerospace sectors, the formal approach to systems and software production has spread throughout the industry since the early 1970s. The original goal was to improve programmer productivity - the tools concentrated on code generation and project management. But it became evident during the 1980s that the 'engineering' approach had broader potential. Concepts such as 'information engineering' - where a company's entire operation is modelled as a set of formal processes - gained credibility. James Martin, one of its leading advocates, saw that companies could gain competitive edge in their markets if they could identify applications which brought high return on investment. The advanced design and production tools now available to systems builders, provide the technology to support this vision and produce such applications quickly. Nowadays, most serious systems and software development is undertaken within a formal 'engineering' framework. The final goal of the system is defined, the systems needed to achieve it are specified and the criteria for its delivery and support are established. CASE methods like Yourdon provide the theoretical foundation. They provide the link between the informality of the real world and the formality of the computer model. In its fullest sense, CASE embraces every stage of the development of a system from the identification of a business need, through development, to maintenance and 'live' running. All CASE methods use the concept of the formal software 'life cycle' as their base and attempt to enforce rigorous design principles throughout. A system is broken down into a set of components which can be assembled to create a complete system. The development of the individual components is managed within the context of the whole system to ensure consistency. This is a broad area of activity which can be broken down into two distinct areas: 'upper' CASE - which covers business and system design; and 'lower' CASE - which covers the development process. The 'upper' CASE tools and disciplines are used to gather data and evolve a specification in the form of a data dictionary or system repository. They may also be capable of simulating a completed system to demonstrate to users. The 'lower' CASE tools use the design 'dictionary' to generate code for the final live system. Any design changes must, of course, be made at the 'upper' level to maintain the integrity of the design. At its most ambitious, so-called 'integrated CASE' combines both the design tools and the production tools in a 'seamless' continuum. But most early experiences of CASE have, for historical reasons, involved a mixture of tools and disciplines. A company might like a particular design tool, but want to use a code generator from a different supplier. Not surprisingly, this has led to the need for a certain amount of standardisation of CASE tools, the methods they support and the systems for which they can generate applications code. IBM's Application Development (AD)/Cycle is the most ambitious initiative in this direction. There are also international standards efforts aimed at defining a specification for a general-purpose system 'dictionary.' This will make it possible for a wide range of 'upper' CASE tools to build specifications for a wide range of code generators. This is still a long way from the complete automation of the system-building process. CASE requires a lot of human interference - to get round quirks in design, which cannot be accommodated by the technology, or to meet the need for special-purpose code which the code generator cannot produce. It is also complicated by the change in the underlying infrastructure of information technology. Applications are no longer built for a single computer - or even to meet a single need. In the 1990s, they can be spread across a wide range of technologies from a laptop computer to a giant mainframe.</p>
		</main>
</body></html>
            